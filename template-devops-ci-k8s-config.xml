<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@1559.va_a_533730b_ea_d">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition@2.2277.v00573e73ddf1"/>
    <org.jenkinsci.plugins.workflow.multibranch.JobPropertyTrackerAction plugin="workflow-multibranch@821.vc3b_4ea_780798">
      <jobPropertyDescriptors>
        <string>org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty</string>
      </jobPropertyDescriptors>
    </org.jenkinsci.plugins.workflow.multibranch.JobPropertyTrackerAction>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition@2.2277.v00573e73ddf1">
      <jobProperties/>
      <triggers/>
      <parameters>
        <string>ref</string>
        <string>repo</string>
      </parameters>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>repo</name>
          <description>Repository name</description>
          <defaultValue>saas-apigateway</defaultValue>
          <trim>false</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>ref</name>
          <description>Git ref or branch</description>
          <defaultValue>develop</defaultValue>
          <trim>false</trim>
        </hudson.model.StringParameterDefinition>
      </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
    <hudson.plugins.throttleconcurrents.ThrottleJobProperty plugin="throttle-concurrents@2.18">
      <maxConcurrentPerNode>0</maxConcurrentPerNode>
      <maxConcurrentTotal>0</maxConcurrentTotal>
      <categories class="java.util.concurrent.CopyOnWriteArrayList"/>
      <throttleEnabled>false</throttleEnabled>
      <throttleOption>project</throttleOption>
      <limitOneJobWithMatchingParams>false</limitOneJobWithMatchingParams>
      <paramsToUseForLimit></paramsToUseForLimit>
    </hudson.plugins.throttleconcurrents.ThrottleJobProperty>
    <org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
      <triggers>
        <hudson.triggers.SCMTrigger>
          <spec>H/3 * * * *</spec>
          <ignorePostCommitHooks>false</ignorePostCommitHooks>
        </hudson.triggers.SCMTrigger>
      </triggers>
    </org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@4209.v83c4e257f1e9">
    <script>pipeline {
    agent any

    parameters {
        string(name: &apos;repo&apos;, defaultValue: &apos;saas-apigateway&apos;, description: &apos;Repository name&apos;)
        string(name: &apos;ref&apos;, defaultValue: &apos;develop&apos;, description: &apos;Git ref or branch&apos;)
    }




    environment {
        REGISTRY01 = &quot;loyaltolpi&quot;
        REGISTRY_URL = &quot;http://193.1.1.3:5000&quot;
        // Uncomment below if using Jenkins credentials instead
        /*
        REGISTRY01      = credentials(&apos;REGISTRY01_URL&apos;)
        GITUSERTOKEN    = credentials(&apos;GITUSERTOKEN&apos;)
        BITBUCKET_USER  = credentials(&apos;BITBUCKET_USER&apos;)
        BITBUCKET_TOKEN = credentials(&apos;BITBUCKET_TOKEN&apos;)
        GITHUB_USER     = credentials(&apos;GITHUB_USER&apos;)
        GITHUB_TOKEN    = credentials(&apos;GITHUB_TOKEN&apos;)
        */
        BITBUCKET_URL = &quot;https://bitbucket.org/loyaltoid/${params.repo}.git&quot;
        CREDENTIALS_ID = &apos;newrahmat-bb&apos;
        
        CPU_PERIOD = &apos;100000&apos;
        CPU_QUOTA = &apos;150000&apos;
        MEMORY= &apos;512m&apos;        
        
    }

    stages {
     

stage(&apos;Fetch Build Metadata&apos;) {
    steps {
        script {
            def response = sh(
                script: &quot;&quot;&quot;curl -s -X GET &quot;http://193.1.1.3:5000/v1/file?repo=${params.repo}&amp;refs=${params.ref}&amp;path=cicd%2Fcicd.json&quot; -H &quot;accept: application/json&quot; &quot;&quot;&quot;,
                returnStdout: true
            ).trim()

            def json = new groovy.json.JsonSlurperClassic().parseText(response)

            json.each { key, value -&gt;
                // Hanya isi ke env jika key-nya huruf besar semua
                if (key == key.toUpperCase()) {
                    env.&quot;${key}&quot; = value.toString()
                }
            }
        }
    }
}


//         stage(&apos;Prepare&apos;) {
//             steps {
// script {
// echo &quot;Project name is: ${env.PROJECT}&quot;    
    
//     sh&quot;rm -rf *&quot;
//     sh&quot;rm -rf .git&quot;
//              def containerName = &quot;${params.repo}-${params.ref}&quot;

//             sh &quot;&quot;&quot;
//             docker ps -a --format &apos;{{.Names}}&apos; | grep -w ${containerName} &amp;&amp; docker stop ${containerName} || true
//             docker ps -a --format &apos;{{.Names}}&apos; | grep -w ${containerName} &amp;&amp; docker rm ${containerName} || true
//             &quot;&quot;&quot;
     
    
// }
//             }
//         }


        stage(&apos;Check Image Ready&apos;) {
            steps {
                script {
                    if (!env.repo || !env.ref) {
                        error &quot;‚ùå Parameter &apos;repo&apos; atau &apos;ref&apos; tidak tersedia dari payload webhook.&quot;
                    }

                    echo &quot;üîç Memeriksa image untuk repo: ${env.repo}, ref: ${env.ref}&quot;

                    def url = &quot;${REGISTRY_URL}/v1/image?repo=${env.repo}&amp;refs=${env.ref}&quot;
                    def response = sh(
                        script: &quot;&quot;&quot;curl -s -X GET &quot;${url}&quot; -H &quot;accept: application/json&quot; &quot;&quot;&quot;,
                        returnStdout: true
                    ).trim()

                    def json
                    try {
                        json = new groovy.json.JsonSlurperClassic().parseText(response)
                    } catch (e) {
                        error &quot;‚ùå Gagal parsing JSON: ${e.message}\nRespon: ${response}&quot;
                    }

                    if (json.ready == true) {
                        echo &quot;‚úÖ Image is ready.&quot;
                        env.IMAGE_READY = &quot;true&quot;
                        // env.IMAGE_READY = &quot;false&quot;
                        env.READY_IMAGE = json.image ?: &quot;&quot;
                    } else {
                        echo &quot;üõ† Image not ready.&quot;
                        env.IMAGE_READY = &quot;false&quot;
                    }
                }
            }
        }


stage(&apos;Docker Build &amp; Push&apos;) {
    when {
        expression { env.IMAGE_READY == &quot;false&quot; }
    }
    
    steps {
        script {
            // Set job display name
            currentBuild.displayName = &quot;${params.repo}-${params.ref}&quot;
            
            // Build and push docker image
            sh &quot;&quot;&quot;devops-ci ${params.repo} ${params.ref} --json&quot;&quot;&quot;
        }
    }
}

        stage(&apos;Check Image&apos;) {
            steps {
                script {
                    if (!env.repo || !env.ref) {
                        error &quot;‚ùå Parameter &apos;repo&apos; atau &apos;ref&apos; tidak tersedia dari payload webhook.&quot;
                    }

                    echo &quot;üîç Memeriksa image untuk repo: ${env.repo}, ref: ${env.ref}&quot;

                    def url = &quot;${REGISTRY_URL}/v1/image?repo=${env.repo}&amp;refs=${env.ref}&quot;
                    def response = sh(
                        script: &quot;&quot;&quot;curl -s -X GET &quot;${url}&quot; -H &quot;accept: application/json&quot; &quot;&quot;&quot;,
                        returnStdout: true
                    ).trim()

                    def json
                    try {
                        json = new groovy.json.JsonSlurperClassic().parseText(response)
                    } catch (e) {
                        error &quot;‚ùå Gagal parsing JSON: ${e.message}\nRespon: ${response}&quot;
                    }

                    if (json.ready == true) {
                        echo &quot;‚úÖ Image is ready.&quot;
                        env.IMAGE_READY = &quot;true&quot;
                        env.READY_IMAGE = json.image ?: &quot;&quot;
                    } else {
                        echo &quot;üõ† Image not ready.&quot;
                        env.IMAGE_READY = &quot;false&quot;
                    }
                }
            }
        }
        
        
    }

    post {
        success {
            echo &apos;‚úÖ Docker image built and pushed successfully!&apos;
        }
        failure {
            echo &apos;‚ùå Build or push failed!&apos;
        }
    }
}
</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>
