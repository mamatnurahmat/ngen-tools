<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@1559.va_a_533730b_ea_d">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition@2.2277.v00573e73ddf1"/>
    <org.jenkinsci.plugins.workflow.multibranch.JobPropertyTrackerAction plugin="workflow-multibranch@821.vc3b_4ea_780798">
      <jobPropertyDescriptors>
        <string>org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty</string>
      </jobPropertyDescriptors>
    </org.jenkinsci.plugins.workflow.multibranch.JobPropertyTrackerAction>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition@2.2277.v00573e73ddf1">
      <jobProperties/>
      <triggers>
        <string>org.jenkinsci.plugins.gwt.GenericTrigger</string>
      </triggers>
      <parameters>
        <string>REF_TYPE</string>
        <string>REF_NAME</string>
      </parameters>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>REF_NAME</name>
          <description>Branch or Tag Name</description>
          <defaultValue>develop</defaultValue>
          <trim>false</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.ChoiceParameterDefinition>
          <name>REF_TYPE</name>
          <description>Type (branch or tag)</description>
          <choices class="java.util.Arrays$ArrayList">
            <a class="string-array">
              <string>branch</string>
              <string>tag</string>
            </a>
          </choices>
        </hudson.model.ChoiceParameterDefinition>
      </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
    <hudson.plugins.throttleconcurrents.ThrottleJobProperty plugin="throttle-concurrents@2.18">
      <maxConcurrentPerNode>0</maxConcurrentPerNode>
      <maxConcurrentTotal>0</maxConcurrentTotal>
      <categories class="java.util.concurrent.CopyOnWriteArrayList"/>
      <throttleEnabled>false</throttleEnabled>
      <throttleOption>project</throttleOption>
      <limitOneJobWithMatchingParams>false</limitOneJobWithMatchingParams>
      <paramsToUseForLimit></paramsToUseForLimit>
    </hudson.plugins.throttleconcurrents.ThrottleJobProperty>
    <org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
      <triggers>
        <hudson.triggers.SCMTrigger>
          <spec>* * * * *</spec>
          <ignorePostCommitHooks>false</ignorePostCommitHooks>
        </hudson.triggers.SCMTrigger>
        <org.jenkinsci.plugins.gwt.GenericTrigger plugin="generic-webhook-trigger@2.4.1">
          <spec></spec>
          <genericVariables>
            <org.jenkinsci.plugins.gwt.GenericVariable>
              <key>ref</key>
              <value>$.push.changes[0].new.name</value>
            </org.jenkinsci.plugins.gwt.GenericVariable>
            <org.jenkinsci.plugins.gwt.GenericVariable>
              <key>type</key>
              <value>$.push.changes[0].new.type</value>
            </org.jenkinsci.plugins.gwt.GenericVariable>
            <org.jenkinsci.plugins.gwt.GenericVariable>
              <key>repo</key>
              <value>$.repository.name</value>
            </org.jenkinsci.plugins.gwt.GenericVariable>
          </genericVariables>
          <regexpFilterText>${type}:${ref}</regexpFilterText>
          <regexpFilterExpression>^(branch:(develop|development|staging)|tag:v.*)$</regexpFilterExpression>
          <printPostContent>true</printPostContent>
          <printContributedVariables>true</printContributedVariables>
          <token>saas-be-identity-manager</token>
          <silentResponse>false</silentResponse>
          <overrideQuietPeriod>false</overrideQuietPeriod>
          <shouldNotFlattern>false</shouldNotFlattern>
          <allowSeveralTriggersPerBuild>false</allowSeveralTriggersPerBuild>
        </org.jenkinsci.plugins.gwt.GenericTrigger>
      </triggers>
    </org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@4218.vff679a_5c0f3a_">
    <script>// properties([pipelineTriggers([pollSCM(&apos;H/3 * * * *&apos;)])])

def FAILED_STAGE
def imageReady = false
def teamsNotification(status, message, gitInfo = [:]) {
    def themeColor = &apos;808080&apos;
    switch (status) {
        case &apos;SUCCESS&apos;: themeColor = &apos;00FF00&apos;; break
        case &apos;FAILURE&apos;: themeColor = &apos;FF0000&apos;; break
        case &apos;STARTED&apos;: themeColor = &apos;0000FF&apos;; break
        case &apos;WAITING_APPROVE&apos;: themeColor = &apos;FFFF00&apos;; break        
    }

    withCredentials([string(credentialsId: &apos;TEAMS_WEBHOOK_URL&apos;, variable: &apos;WEBHOOK_URL&apos;)]) {
        writeFile file: &apos;teams_payload.json&apos;, text: &quot;&quot;&quot;{
            &quot;@type&quot;: &quot;MessageCard&quot;,
            &quot;@context&quot;: &quot;http://schema.org/extensions&quot;,
            &quot;summary&quot;: &quot;Build Notification&quot;,
            &quot;themeColor&quot;: &quot;${themeColor}&quot;,
            &quot;title&quot;: &quot;Jenkins Build ${status}&quot;,
            &quot;sections&quot;: [{
                &quot;activityTitle&quot;: &quot;${message}&quot;,
                &quot;activitySubtitle&quot;: &quot;Job Name: ${env.JOB_NAME}&quot;,
                &quot;facts&quot;: [
                    {&quot;name&quot;: &quot;Build Number&quot;, &quot;value&quot;: &quot;${env.BUILD_NUMBER}&quot;},
                    {&quot;name&quot;: &quot;Branch&quot;, &quot;value&quot;: &quot;${env.GIT_BRANCH}&quot;},
                    {&quot;name&quot;: &quot;VERSION&quot;, &quot;value&quot;: &quot;${env.TAG_VERSION ?: &apos;N/A&apos;}&quot;},
                    {&quot;name&quot;: &quot;Commit Message&quot;, &quot;value&quot;: &quot;${env.GIT_MESSAGE ?: &apos;N/A&apos;}&quot;},
                    {&quot;name&quot;: &quot;Commit Date&quot;, &quot;value&quot;: &quot;${env.GIT_DATE ?: &apos;N/A&apos;}&quot;},
                    {&quot;name&quot;: &quot;Author&quot;, &quot;value&quot;: &quot;${env.GIT_AUTHOR ?: &apos;N/A&apos;}&quot;},
                    {&quot;name&quot;: &quot;Author Email&quot;, &quot;value&quot;: &quot;${env.GIT_EMAIL ?: &apos;N/A&apos;}&quot;}
                ],
                &quot;potentialAction&quot;: [{
                    &quot;@type&quot;: &quot;OpenUri&quot;,
                    &quot;name&quot;: &quot;View Job&quot;,
                    &quot;targets&quot;: [{&quot;os&quot;: &quot;default&quot;, &quot;uri&quot;: &quot;${env.BUILD_URL}&quot;}]
                }]
            }]
        }&quot;&quot;&quot;

        sh &quot;curl -H &apos;Content-Type: application/json&apos; --data @teams_payload.json \&quot;\$WEBHOOK_URL\&quot;&quot;
    }
}


pipeline {
    agent any

    environment {
        REGISTRY_URL = &quot;http://193.1.1.3:5000&quot;
    }

    parameters {
        string(name: &apos;REF_NAME&apos;, defaultValue: &apos;develop&apos;, description: &apos;Branch or Tag Name&apos;)
        choice(name: &apos;REF_TYPE&apos;, choices: [&apos;branch&apos;, &apos;tag&apos;], description: &apos;Type (branch or tag)&apos;)
    }

    triggers {
        GenericTrigger(
            genericVariables: [
                [key: &apos;ref&apos;, value: &apos;$.push.changes[0].new.name&apos;],
                [key: &apos;type&apos;, value: &apos;$.push.changes[0].new.type&apos;],
                [key: &apos;repo&apos;, value: &apos;$.repository.name&apos;]
            ],
            token: &quot;${env.JOB_NAME}&quot;,
            printContributedVariables: true,
            printPostContent: true,
            regexpFilterExpression: &apos;^(branch:(develop|development|staging)|tag:v.*)$&apos;,
            regexpFilterText: &apos;${type}:${ref}&apos;
        )
    }

    stages {
        stage(&apos;Check Branch or Tag&apos;) {
            steps {
                script {
                
                    env.FAILED_STAGE = &quot;${env.DISPLAY_NAME}&quot;
                    echo &quot;Running Build &amp; Deploy for ${env.ref} (${env.type})&quot;
                    
                    echo &quot;DEBUG: Webhook REF = &apos;${env.ref}&apos;, Webhook TYPE = &apos;${env.type}&apos;, Webhook REPO = &apos;${env.repo}&apos;&quot;
                    echo &quot;DEBUG: Manual REF = &apos;${params.REF_NAME}&apos;, Manual TYPE = &apos;${params.REF_TYPE}&apos;&quot;

                    def ref = (env.ref &amp;&amp; env.ref != &apos;/usr/share/jenkins/ref&apos;) ? env.ref.trim() : params.REF_NAME.trim()
                    def type = (env.type &amp;&amp; env.type != &apos;/usr/share/jenkins/type&apos;) ? env.type.trim() : params.REF_TYPE.trim()
                    def repo = (env.repo &amp;&amp; env.repo != &apos;/usr/share/jenkins/repo&apos;) ? env.repo.trim() : env.JOB_NAME.tokenize(&apos;/&apos;)[0]

                    echo &quot;Final REF_NAME=${ref}, Final REF_TYPE=${type}, Final REPO=${repo}&quot;

                    // Validasi branch/tag hanya jika tidak kosong
                    if (!ref || !type) {
                        error &quot;ERROR: Branch/tag tidak valid atau tidak terdeteksi.&quot;
                    }

                    // Branch &amp; Tag yang diizinkan
                    def allowedBranches = [&apos;develop&apos;, &apos;development&apos;, &apos;staging&apos;]
                    def isBranchAllowed = (type == &apos;branch&apos; &amp;&amp; allowedBranches.contains(ref))
                    def isTagAllowed = (type == &apos;tag&apos; &amp;&amp; ref.startsWith(&apos;v&apos;))

                    if (isBranchAllowed || isTagAllowed) {
                        echo &quot;Build akan dijalankan untuk ${ref} (${type})&quot;
                        env.ref = ref
                        env.type = type
                        env.repo = repo
                    } else {
                        error &quot; Branch/tag &apos;${ref}&apos; tidak diizinkan untuk build.&quot;
                    }
                    currentBuild.displayName = &quot;${env.repo}-${env.ref}&quot;                    
                    teamsNotification(&apos;STARTED&apos;, &quot;Job ${env.JOB_NAME} #${env.BUILD_NUMBER} STARTED. [View Job](${env.BUILD_URL})&quot;)

                }
            }
        }

        
        
        stage(&apos;Check Image Ready&apos;) {
            steps {
                script {
                    env.FAILED_STAGE = &quot;${env.DISPLAY_NAME}&quot;
                    echo &quot;Running Build &amp; Deploy for ${env.ref} (${env.type})&quot;
                    
                    if (!env.repo || !env.ref) {
                        error &quot; Parameter &apos;repo&apos; atau &apos;ref&apos; tidak tersedia dari payload webhook.&quot;
                    }

                    echo &quot; Memeriksa image untuk repo: ${env.repo}, ref: ${env.ref}&quot;

                    def url = &quot;${REGISTRY_URL}/v1/image?repo=${env.repo}&amp;refs=${env.ref}&quot;
                    def response = sh(
                        script: &quot;&quot;&quot;curl -s -X GET &quot;${url}&quot; -H &quot;accept: application/json&quot; &quot;&quot;&quot;,
                        returnStdout: true
                    ).trim()

                    def json
                    try {
                        json = new groovy.json.JsonSlurperClassic().parseText(response)
                    } catch (e) {
                        error &quot; Gagal parsing JSON: ${e.message}\nRespon: ${response}&quot;
                    }

                    if (json.ready == true) {
                        echo &quot; Image is ready.&quot;
                        env.IMAGE_READY = &quot;true&quot;
                        env.READY_IMAGE = json.image ?: &quot;&quot;
                    } else {
                        echo &quot;Image not ready.&quot;
                        env.IMAGE_READY = &quot;false&quot;
                    }
                }
            }
        }


stage(&apos;Fetch Build Metadata&apos;) {
    steps {
        script {
            env.FAILED_STAGE = &quot;${env.DISPLAY_NAME}&quot;
            echo &quot;Running Build &amp; Deploy for ${env.ref} (${env.type})&quot;
            
            
            def response = sh(
                script: &quot;&quot;&quot;curl -s -X GET &quot;${REGISTRY_URL}/v1/file?repo=${env.repo}&amp;refs=${env.ref}&amp;path=cicd%2Fcicd.json&quot; -H &quot;accept: application/json&quot; &quot;&quot;&quot;,
                returnStdout: true
            ).trim()

            def json = new groovy.json.JsonSlurperClassic().parseText(response)

            json.each { key, value -&gt;
                // Hanya isi ke env jika key-nya huruf besar semua
                if (key == key.toUpperCase()) {
                    env.&quot;${key}&quot; = value.toString()
                }
            }
        }
    }
}


        stage(&apos;CI Build &amp; Push&apos;) {
            when {
                expression { env.IMAGE_READY == &quot;false&quot; }
            }
            steps {
                script {
                    
                    env.FAILED_STAGE = &quot;${env.DISPLAY_NAME}&quot;
                    echo &quot;Running Build &amp; Deploy for ${env.ref} (${env.type})&quot;
                    
                    
                    echo &quot; Build karena image belum tersedia.&quot;
                    build job: &quot;devops-ci-k8s&quot;,
                        parameters: [
                            string(name: &apos;repo&apos;, value: env.repo),
                            string(name: &apos;ref&apos;, value: env.ref)
                        ],
                        wait: true
                    echo &quot;Running Build &amp; Deploy for ${env.ref} (${env.type})&quot;

                    def url = &quot;${REGISTRY_URL}/v1/image?repo=${env.repo}&amp;refs=${env.ref}&quot;
                    def response = sh(
                        script: &quot;&quot;&quot;curl -s -X GET &quot;${url}&quot; -H &quot;accept: application/json&quot; &quot;&quot;&quot;,
                        returnStdout: true
                    ).trim()

                    def json
                    try {
                        json = new groovy.json.JsonSlurperClassic().parseText(response)
                    } catch (e) {
                        error &quot;Gagal parsing JSON: ${e.message}\nRespon: ${response}&quot;
                    }

                    if (json.ready == true) {
                        echo &quot; Image is ready.&quot;
                        env.IMAGE_READY = &quot;true&quot;
                        env.READY_IMAGE = json.image ?: &quot;&quot;
                    } else {
                        echo &quot; Image not ready.&quot;
                        env.IMAGE_READY = &quot;false&quot;
                    }                        
                        
                    echo &quot;Running Build &amp; Deploy for ${env.ref} (${env.type})&quot;
                        
                }
            }
        }

        stage(&apos;CVES STEP&apos;) {
            when {
                expression { env.IMAGE_READY == &quot;true&quot; }
            }
            steps {
                script {

                    env.FAILED_STAGE = &quot;${env.DISPLAY_NAME}&quot;
                    echo &quot;Running Build &amp; Deploy for ${env.ref} (${env.type})&quot;
                    
                    echo &quot;Menjalankan CVES job untuk ${env.repo}&quot;
                    build job: &quot;cves-job&quot;,
                        parameters: [
                            string(name: &apos;repo&apos;, value: env.repo),
                            string(name: &apos;refs&apos;, value: env.ref)
                        ],
                        wait: false
                }
            }
        }

        stage(&apos;Check Existing K8s Image Match&apos;) {
            when {
                expression { env.IMAGE_READY == &quot;true&quot; }
            }
            steps {
                withCredentials([string(credentialsId: &apos;API_KEY_DEVOPS&apos;, variable: &apos;API_TOKEN&apos;)]) {
                    script {
                        env.FAILED_STAGE = &quot;${env.DISPLAY_NAME}&quot;
                        echo &quot;Running Build &amp; Deploy for ${env.ref} (${env.type})&quot;
                        
                        def role = env.repo.tokenize(&apos;-&apos;)[1]
                        def validRefs = [&apos;develop&apos;, &apos;development&apos;, &apos;staging&apos;]
                        def refPrefix = validRefs.contains(env.ref) ? env.ref : &apos;dev&apos;
                        def ns = &quot;${refPrefix}-${env.PROJECT}&quot;
                        env.NAMESPACE = ns

                        echo &quot; Mengecek image aktif di namespace: ${ns}&quot;

                        def response = sh(
                            script: &quot;&quot;&quot;curl -s -X GET &quot;${REGISTRY_URL}/v1/k8s-version?ns=${ns}&amp;deployment=${env.repo}&quot; \\
                                -H &quot;accept: application/json&quot; \\
                                -H &quot;Authorization: ${API_TOKEN}&quot; &quot;&quot;&quot;,
                            returnStdout: true
                        ).trim()

                        def result = new groovy.json.JsonSlurperClassic().parseText(response)
                        def deployedImage = result.image?.toString()

                        echo &quot;READY_IMAGE: ${env.READY_IMAGE}&quot;
                        echo &quot;DEPLOYED_IMAGE: ${deployedImage}&quot;

                        if (deployedImage == env.READY_IMAGE) {
                            echo &quot; Image match. Melewati stage deployment.&quot;
                            env.SKIP_DEPLOY = &quot;true&quot;
                        } else {
                            echo &quot; Image berbeda. Akan lanjut ke deployment.&quot;
                            env.SKIP_DEPLOY = &quot;false&quot;
                        }
                    }
                }
            }
        }

        stage(&apos;DEPLOY K8S&apos;) {
            when {
                allOf {
                    expression { env.IMAGE_READY == &quot;true&quot; }
                    expression { env.SKIP_DEPLOY != &quot;true&quot; }
                }
            }
            steps {
                withCredentials([string(credentialsId: &apos;API_KEY_DEVOPS&apos;, variable: &apos;API_TOKEN&apos;)]) {
                    script {
                        env.FAILED_STAGE = &quot;${env.DISPLAY_NAME}&quot;
                        echo &quot;Running Build &amp; Deploy for ${env.ref} (${env.type})&quot;
    
                        def payload = &quot;&quot;&quot;{
                            &quot;deployment&quot;: &quot;${env.repo}&quot;,
                            &quot;ns&quot;: &quot;${env.NAMESPACE}&quot;,
                            &quot;refs&quot;: &quot;${env.ref}&quot;,
                            &quot;repo&quot;: &quot;${env.repo}&quot;
                        }&quot;&quot;&quot;

                        echo &quot;Melakukan deployment via API&quot;

                        sh &quot;&quot;&quot;
                        curl -s -X POST &quot;${REGISTRY_URL}/v1/set-image&quot; \\
                            -H &quot;accept: application/json&quot; \\
                            -H &quot;Authorization: ${API_TOKEN}&quot; \\
                            -H &quot;Content-Type: application/json&quot; \\
                            -d &apos;${payload}&apos;
                        &quot;&quot;&quot;
                    }
                }
            }
        }
    }

    post {
        failure {
            echo &quot;Build gagal untuk ${env.ref} (${env.type})&quot;
            teamsNotification(&apos;FAILURE&apos;, &quot;STEP: ${FAILED_STAGE} - Job ${env.JOB_NAME} #${env.BUILD_NUMBER} FAILED. [View Job](${env.BUILD_URL})&quot;)
        }
        success {
            echo &quot;Build berhasil untuk ${env.ref} (${env.type})&quot;
                teamsNotification(&apos;SUCCESS&apos;, &quot;Job ${env.JOB_NAME} #${env.BUILD_NUMBER} SUCCESS. [View Job](${env.BUILD_URL})&quot;)            
        }
    }
}</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>
